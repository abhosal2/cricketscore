<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Match Scoreboard</title>
  <style>
    body {
      font-family: "Centaur", serif;
      background-color: #000; /* Solid black background */
      color: white;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 0 0 8px rgba(255,255,255,0.5);
    }
    .scoreboard {
      background: rgba(30,30,30,0.85);
      border-radius: 10px;
      padding: 20px;
      max-width: 560px;
      margin: 0 auto;
      box-shadow: 0 0 15px rgba(255,255,255,0.2);
    }
    .line {
      margin: 10px 0;
      font-size: 18px;
    }
    #score {
      font-size: 26px; /* bigger score font */
      font-weight: 700;
      letter-spacing: 0.3px;
    }
    .commentary {
      margin-top: 20px;
      padding: 15px;
      background: rgba(50,50,50,0.9);
      border-radius: 8px;
      font-style: italic;
      box-shadow: inset 0 0 8px rgba(255,255,255,0.2);
    }
    .stats {
      margin-top: 16px;
      padding: 12px 14px;
      background: rgba(40,40,40,0.9);
      border-radius: 8px;
      text-align: left;
    }
    .stats h3 {
      margin: 0 0 10px 0;
      font-size: 18px;
      text-align: center;
      color: #eaeaea;
      text-shadow: 0 0 6px rgba(255,255,255,0.15);
    }
    .statline {
      margin: 6px 0;
      font-size: 16px;
    }
    .name {
      font-weight: 700;
      letter-spacing: 0.2px;
    }
  </style>
</head>
<body>
  <h1>üèè Live Match Scoreboard</h1>

  <div class="scoreboard">
    <div class="line"><strong>Batting Team:</strong> <span id="battingTeam">Loading...</span></div>
    <div class="line"><strong>Bowling Team:</strong> <span id="bowlingTeam">Loading...</span></div>

    <div class="line"><strong>Score:</strong> <span id="score">0/0 (0.0 overs)</span></div>
    <div class="line"><strong>NRR:</strong> <span id="nrr">0.00</span></div>

    <div class="line">
      <strong>Striker:</strong> <span id="striker">None</span> |
      <strong>Non-Striker:</strong> <span id="nonStriker">None</span>
    </div>
    <div class="line"><strong>Bowler:</strong> <span id="bowler">None</span></div>

    <div class="stats">
      <h3>Current Player & Bowler Stats</h3>
      <div class="statline"><span class="name">Striker:</span> <span id="strikerStats">‚Äì</span></div>
      <div class="statline"><span class="name">Non-Striker:</span> <span id="nonStrikerStats">‚Äì</span></div>
      <div class="statline"><span class="name">Bowler:</span> <span id="bowlerStats">‚Äì</span></div>
    </div>

    <div class="commentary" id="commentary">üì¢ Commentary will appear here...</div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://ukziqsqffdavuctzyngn.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVremlxc3FmZmRhdnVjdHp5bmduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzA4MDQsImV4cCI6MjA3MzYwNjgwNH0.d8c2lnVKhoVLHHI3pKBLr9kaE1zB-ll5CjvFE8bZxQs";
    const { createClient } = supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const matchId = localStorage.getItem("matchId");

    // Cached match/team context
    let team1 = null, team2 = null;
    let team1Players = [], team2Players = [];
    let lastBattingTeam = null, lastBowlingTeam = null;

    // --- Helpers ---
    function formatOversForDisplay(oversVal) {
      const num = Number(oversVal || 0);
      return num.toFixed(1);
    }
    function oversToTrueFloat(oversVal) {
      const num = Number(oversVal || 0);
      const whole = Math.trunc(num);
      const balls = Math.round((num - whole) * 10);
      return whole + (balls / 6);
    }
    function computeNRR(runs, oversCricketFmt) {
      const trueOvers = oversToTrueFloat(oversCricketFmt);
      return trueOvers > 0 ? (runs / trueOvers).toFixed(2) : "0.00";
    }
    function byName(list) {
      return (list || []).map(p => (typeof p === "string" ? p : p?.name)).filter(Boolean);
    }
    function isResetRow(row) {
      return Number(row?.runs) === 0 && Number(row?.wickets) === 0 && Number(row?.overs) === 0;
    }

    function inferTeamNamesFromState(scoreRow) {
      // Prefer actual players on strike to infer batting side
      if (team1 && team2) {
        const s = scoreRow?.striker || "";
        const ns = scoreRow?.non_striker || "";
        if (team1Players.includes(s) || team1Players.includes(ns)) {
          return { batting: team1.name, bowling: team2.name };
        }
        if (team2Players.includes(s) || team2Players.includes(ns)) {
          return { batting: team2.name, bowling: team1.name };
        }
      }

      // New innings reset ‚Üí swap from last known sides
      if (isResetRow(scoreRow) && lastBattingTeam && lastBowlingTeam) {
        return { batting: lastBowlingTeam, bowling: lastBattingTeam ? lastBattingTeam /* placeholder, swapped later */ : lastBowlingTeam };
      }

      // Fallback: initial toss decision (first innings only)
      if (team1 && team2 && team1.toss_winner && team1.toss_decision) {
        const tw = team1.toss_winner; // "team1" | "team2"
        const td = team1.toss_decision; // "bat" | "bowl"
        if ((tw === "team1" && td === "bat") || (tw === "team2" && td === "bowl")) {
          return { batting: team1.name, bowling: team2.name };
        } else {
          return { batting: team2.name, bowling: team1.name };
        }
      }
      return { batting: team1?.name || "Team 1", bowling: team2?.name || "Team 2" };
    }

    // Clean swap utility for reset branch
    function swapSides(names) { return { batting: names.bowling, bowling: names.batting }; }

    function renderBasic(scoreRow, teamNames) {
      document.getElementById("battingTeam").textContent = teamNames.batting || "Unknown";
      document.getElementById("bowlingTeam").textContent = teamNames.bowling || "Unknown";

      if (scoreRow) {
        const oversDisp = formatOversForDisplay(scoreRow.overs);
        document.getElementById("score").textContent = `${scoreRow.runs}/${scoreRow.wickets} (${oversDisp} overs)`;
        document.getElementById("nrr").textContent = computeNRR(scoreRow.runs, scoreRow.overs);

        document.getElementById("striker").textContent = scoreRow.striker || "None";
        document.getElementById("nonStriker").textContent = scoreRow.non_striker || "None";
        document.getElementById("bowler").textContent = scoreRow.bowler || "None";
        document.getElementById("commentary").textContent = scoreRow.commentary || "üì¢ Waiting for updates...";
      } else {
        // Null-safe defaults until the scores row exists
        document.getElementById("score").textContent = `0/0 (0.0 overs)`;
        document.getElementById("nrr").textContent = "0.00";
        document.getElementById("striker").textContent = "None";
        document.getElementById("nonStriker").textContent = "None";
        document.getElementById("bowler").textContent = "None";
        document.getElementById("commentary").textContent = "üì¢ Waiting for updates...";
        document.getElementById("strikerStats").textContent = "‚Äì";
        document.getElementById("nonStrikerStats").textContent = "‚Äì";
        document.getElementById("bowlerStats").textContent = "‚Äì";
      }
    }

    async function renderPerPlayerStats(scoreRow) {
      if (!scoreRow) return;

      // Batsmen
      const sName = scoreRow.striker;
      const nsName = scoreRow.non_striker;

      if (sName || nsName) {
        const names = [sName, nsName].filter(Boolean);
        const { data: batRows } = await supabaseClient
          .from("batting_stats")
          .select("player_name,runs,balls")
          .eq("match_id", matchId)
          .in("player_name", names);

        const map = {};
        (batRows || []).forEach(r => { map[r.player_name] = r; });

        const sRow = sName ? map[sName] : null;
        const nsRow = nsName ? map[nsName] : null;

        document.getElementById("strikerStats").textContent =
          sName ? `${sName}: ${sRow?.runs ?? 0} (${sRow?.balls ?? 0})` : "‚Äì";

        document.getElementById("nonStrikerStats").textContent =
          nsName ? `${nsName}: ${nsRow?.runs ?? 0} (${nsRow?.balls ?? 0})` : "‚Äì";
      } else {
        document.getElementById("strikerStats").textContent = "‚Äì";
        document.getElementById("nonStrikerStats").textContent = "‚Äì";
      }

      // Bowler (overs + balls) ‚Äî guarded & schema-fallback
      const bName = scoreRow.bowler;
      if (!bName || bName === "None") {
        document.getElementById("bowlerStats").textContent = "‚Äì";
        return;
      }

      // First try selecting 'balls'; if it errors (400), fall back without 'balls'
      let bRow = null;
      let bl = 0;
      const q1 = await supabaseClient
        .from("bowling_stats")
        .select("overs,balls,runs_conceded,wickets")
        .eq("match_id", matchId)
        .eq("bowler_name", bName)
        .maybeSingle();

      if (q1.error) {
        // Fallback without 'balls' column
        const q2 = await supabaseClient
          .from("bowling_stats")
          .select("overs,runs_conceded,wickets")
          .eq("match_id", matchId)
          .eq("bowler_name", bName)
          .maybeSingle();
        bRow = q2.data || null;
        bl = 0; // assume 0 balls if not tracked in schema
      } else {
        bRow = q1.data || null;
        bl = bRow?.balls ?? 0;
      }

      const ov = bRow?.overs ?? 0;
      const rc = bRow?.runs_conceded ?? 0;
      const wk = bRow?.wickets ?? 0;

      document.getElementById("bowlerStats").textContent =
        `${bName}: ${ov}.${bl} ov, ${rc} runs, ${wk} wkts`;
    }

    async function loadContext() {
      const { data: matchData } = await supabaseClient
        .from("matches")
        .select("team1_id, team2_id, toss_winner, toss_decision")
        .eq("id", matchId)
        .single();

      if (!matchData) return;

      const team1Res = await supabaseClient.from("teams").select("id,name").eq("id", matchData.team1_id).single();
      const team2Res = await supabaseClient.from("teams").select("id,name").eq("id", matchData.team2_id).single();

      team1 = { id: team1Res.data?.id, name: team1Res.data?.name, toss_winner: matchData.toss_winner, toss_decision: matchData.toss_decision };
      team2 = { id: team2Res.data?.id, name: team2Res.data?.name };

      const t1PlayersRes = await supabaseClient.from("players").select("name").eq("team_id", team1.id);
      const t2PlayersRes = await supabaseClient.from("players").select("name").eq("team_id", team2.id);

      team1Players = byName(t1PlayersRes.data);
      team2Players = byName(t2PlayersRes.data);
    }

    async function loadInitial() {
      if (!matchId) {
        document.getElementById("commentary").textContent = "‚ö†Ô∏è No match selected.";
        return;
      }

      await loadContext();

      // Be null-safe: row may not exist yet
      const { data: scoreData } = await supabaseClient
        .from("scores")
        .select("*")
        .eq("match_id", matchId)
        .maybeSingle();

      // Determine current sides
      let inferred = inferTeamNamesFromState(scoreData);
      if (isResetRow(scoreData) && lastBattingTeam && lastBowlingTeam) {
        inferred = swapSides({ batting: lastBattingTeam, bowling: lastBowlingTeam });
      }

      renderBasic(scoreData, inferred);
      lastBattingTeam = inferred.batting;
      lastBowlingTeam = inferred.bowling;

      if (scoreData) {
        await renderPerPlayerStats(scoreData);
      }
    }

    function subscribeToUpdates() {
      supabaseClient
        .channel("score_updates_" + matchId)
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "scores", filter: `match_id=eq.${matchId}` },
          async (payload) => { await handleScoreRow(payload.new); }
        )
        .on(
          "postgres_changes",
          { event: "UPDATE", schema: "public", table: "scores", filter: `match_id=eq.${matchId}` },
          async (payload) => { await handleScoreRow(payload.new); }
        )
        .subscribe();
    }

    async function handleScoreRow(row) {
      if (!row) return;

      if (!team1 || !team2) {
        await loadContext();
      }

      // Decide sides. If fresh reset to 0/0 (0.0), swap from last known sides.
      let teams;
      if (isResetRow(row) && lastBattingTeam && lastBowlingTeam) {
        teams = swapSides({ batting: lastBattingTeam, bowling: lastBowlingTeam });
      } else {
        teams = inferTeamNamesFromState(row);
      }

      renderBasic(row, teams);
      lastBattingTeam = teams.batting;
      lastBowlingTeam = teams.bowling;

      await renderPerPlayerStats(row);
    }

    loadInitial();
    subscribeToUpdates();
  </script>
</body>
</html>
