<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scorer Panel</title>

  <!-- üîí Protect scoring page -->
  <script>
    const scorerSession = localStorage.getItem("scorerSession");
    if (!scorerSession) {
      window.location.href = "login.html"; // not logged in ‚Üí redirect
    }
  </script>

  <style>
    body {
      font-family: "Copperplate Gothic Light", Arial, sans-serif;
      background: #121212;
      color: white;
      text-align: center;
      padding: 20px;
    }

    .scoreboard, .controls, .selectors, .extras {
      background: #1e1e2f;
      padding: 20px;
      margin: 20px auto;
      border-radius: 10px;
      width: 85%;
      max-width: 950px;
      box-shadow: 0 0 10px #8384D4;
    }

    h1, h2, h3 {
      color: #8384D4;
      margin: 8px 0;
    }

    select, button, input[type="number"], input[type="text"] {
      margin: 6px;
      padding: 10px 14px;
      font-size: 16px;
      border-radius: 6px;
      border: none;
      outline: none;
    }

    select, input[type="number"], input[type="text"] {
      background: #222;
      color: #fff;
    }

    button {
      background: #8384D4;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background: #6c6db8;
    }

    button:disabled {
      background: #444;
      cursor: not-allowed;
    }

    .warn {
      border: 2px solid #ff5252;
      border-radius: 10px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
    }

    /* Simple modal for selecting new bowler after an over */
    .modal-backdrop {
      display: none;
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.6);
      align-items: center; justify-content: center;
      z-index: 9999;
    }
    .modal {
      background: #1e1e2f;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 12px #8384D4;
      width: 90%;
      max-width: 420px;
      text-align: left;
    }
    .modal h3 { margin-top: 0; color: #fff; }
    .modal .actions { margin-top: 12px; display: flex; gap: 10px; justify-content: flex-end; }
  </style>
</head>
<body>
  <h1>üèè Scorer Panel</h1>

  <div class="scoreboard">
    <h2 id="battingTeam">Batting Team: Loading...</h2>
    <h2 id="bowlingTeam">Bowling Team: Loading...</h2>
    <p id="score">Score: 0/0 (0.0 overs)</p>
    <p id="nrr">NRR: 0.00</p>

    <!-- Striker/Non-striker with stats -->
    <p id="striker">Striker: None</p>
    <p id="nonStriker">Non-Striker: None</p>
    <!-- Bowler stats -->
    <p id="bowler">Bowler: None</p>
  </div>

  <!-- Player selectors -->
  <div class="selectors" id="selectorsBox">
    <h3>‚ö° Select Players Before Scoring</h3>
    <div class="row">
      <label>Striker:</label>
      <select id="strikerSelect"><option value="">-- Select --</option></select>

      <label>Non-Striker:</label>
      <select id="nonStrikerSelect"><option value="">-- Select --</option></select>

      <label>Bowler:</label>
      <select id="bowlerSelect"><option value="">-- Select --</option></select>
    </div>
    <div class="row">
      <button id="btnConfirmInitial" onclick="confirmPlayers()">Confirm Players</button>
      <button id="btnConfirmNewBat" style="display:none;" onclick="setNewBatsman()">Confirm New Batsman</button>
      <button id="btnConfirmNewBowler" style="display:none;" onclick="setNewBowler()">Confirm New Bowler</button>
    </div>

    <!-- Dismissal type + fielder input -->
    <div class="row">
      <label for="dismissalType">Dismissal Type:</label>
      <select id="dismissalType">
        <option value="bowled">Bowled</option>
        <option value="caught">Caught</option>
        <option value="lbw">LBW</option>
        <option value="run out">Run Out</option>
        <option value="stumped">Stumped</option>
        <option value="hit wicket">Hit Wicket</option>
      </select>

      <label for="fielderName">Fielder (optional):</label>
      <input type="text" id="fielderName" placeholder="Enter fielder name">
    </div>
  </div>

  <!-- Scoring controls -->
  <div class="controls">
    <div class="row">
      <button id="btn1" onclick="addRun(1)" disabled>+1 Run</button>
      <button id="btn2" onclick="addRun(2)" disabled>+2 Runs</button>
      <button id="btn4" onclick="addRun(4)" disabled>+4 Runs</button>
      <button id="btn6" onclick="addRun(6)" disabled>+6 Runs</button>
      <button id="btnW" onclick="addWicket()" disabled>Wicket</button>
    </div>
    <div class="row">
      <button id="btnSwap" onclick="swapStrike(true)" disabled>Swap Strike</button>
      <button id="btnUndo" onclick="undo()" disabled>Undo</button>
      <button id="btnEnd" onclick="endInnings()" disabled>End Innings</button>
      <button onclick="window.location.href='display.html'">Go to Display Page</button>
    </div>
  </div>

  <!-- Extras -->
  <div class="extras">
    <h3>‚ûï Extras</h3>
    <div class="row">
      <label for="extrasType">Type:</label>
      <select id="extrasType">
        <option value="wide">Wide</option>
        <option value="no_ball">No Ball</option>
        <option value="leg_bye">Leg Bye</option>
      </select>

      <label for="extrasRuns">Runs:</label>
      <input type="number" id="extrasRuns" min="1" value="1" />

      <button id="btnExtra" onclick="addExtra()" disabled>Add Extra</button>
    </div>
  </div>

  <!-- Over-end Bowler Modal -->
  <div class="modal-backdrop" id="bowlerModal">
    <div class="modal">
      <h3>Select new bowler for the next over</h3>
      <select id="newBowlerSelect" style="width:100%"><option value="">-- Select Bowler --</option></select>
      <div class="actions">
        <button onclick="closeBowlerModal()">Cancel</button>
        <button onclick="confirmBowlerModal()">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://ukziqsqffdavuctzyngn.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVremlxc3FmZmRhdnVjdHp5bmduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwMzA4MDQsImV4cCI6MjA3MzYwNjgwNH0.d8c2lnVKhoVLHHI3pKBLr9kaE1zB-ll5CjvFE8bZxQs";
    const { createClient } = supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // ------- STATE -------
    let matchId = localStorage.getItem("matchId");
    let runs = 0, wickets = 0, overs = 0, balls = 0; // balls = 0..5
    let striker = "None", non_striker = "None", bowler = "None", commentary = "";
    let battingTeam = "", bowlingTeam = "";
    let battingPlayers = [], bowlingPlayers = [];
    let team1Captain = "", team2Captain = "";
    let waitingNewBatsman = false, waitingNewBowler = false;

    // Undo history entries carry both before-state snapshot and the operation delta
    const history = [];

    // ------- UI HELPERS -------
    function updateDisplay() {
      document.getElementById("score").textContent = `Score: ${runs}/${wickets} (${overs}.${balls} overs)`;
      document.getElementById("striker").textContent = `Striker: ${striker}`;
      document.getElementById("nonStriker").textContent = `Non-Striker: ${non_striker}`;
      document.getElementById("bowler").textContent = `Bowler: ${bowler}`;
      document.getElementById("battingTeam").textContent = `Batting Team: ${battingTeam}`;
      document.getElementById("bowlingTeam").textContent = `Bowling Team: ${bowlingTeam}`;
      const o = overs + balls/6;
      document.getElementById("nrr").textContent = o > 0 ? (runs/o).toFixed(2) : "0.00";
    }
    function oversDecimal() {
      // store as x.y where y is balls (0..5) to fit decimal(4,1)
      return Number((overs + balls/10).toFixed(1));
    }
    function enableScoring(enabled) {
      document.querySelectorAll(".controls button, .extras button").forEach(b=>{
        if (b.textContent.includes("Go to Display Page")) return;
        b.disabled = !enabled;
      });
    }
    function pushHistory(entry) {
      history.push(entry);
      document.getElementById("btnUndo").disabled = false;
    }

    // ------- DB HELPERS (bat/bowl rows) -------
    async function ensureBattingRow(player) {
      if (!player || player === "None") return;
      const { data } = await supabaseClient.from("batting_stats")
        .select("id").eq("match_id", matchId).eq("player_name", player).maybeSingle();
      if (!data) {
        await supabaseClient.from("batting_stats").insert({
          match_id: matchId, player_name: player,
          runs: 0, balls: 0, fours: 0, sixes: 0, is_out: false
        });
      }
    }
    async function ensureBowlingRow(p) {
      if (!p || p === "None") return;
      const { data } = await supabaseClient.from("bowling_stats")
        .select("id").eq("match_id", matchId).eq("bowler_name", p).maybeSingle();
      if (!data) {
        await supabaseClient.from("bowling_stats").insert({
          match_id: matchId, bowler_name: p,
          overs: 0, runs_conceded: 0, wickets: 0
        });
      }
    }
    async function adjBatting(player, druns=0, dballs=0, dfours=0, dsixes=0) {
      if (!player || player==="None") return;
      const { data: row } = await supabaseClient.from("batting_stats")
        .select("runs,balls,fours,sixes").eq("match_id", matchId).eq("player_name", player).single();
      if (!row) return;
      await supabaseClient.from("batting_stats").update({
        runs: Math.max(0, (row.runs||0)+druns),
        balls: Math.max(0, (row.balls||0)+dballs),
        fours: Math.max(0, (row.fours||0)+dfours),
        sixes: Math.max(0, (row.sixes||0)+dsixes),
      }).eq("match_id", matchId).eq("player_name", player);
    }
    async function setBatsmanOut(player, isOut) {
      await supabaseClient.from("batting_stats")
        .update({ is_out: !!isOut })
        .eq("match_id", matchId).eq("player_name", player);
    }
    async function adjBowling(p, dRuns=0, dWkts=0, dOvers=0) {
      if (!p || p==="None") return;
      const { data: row } = await supabaseClient.from("bowling_stats")
        .select("runs_conceded,wickets,overs").eq("match_id", matchId).eq("bowler_name", p).maybeSingle();
      const rc = Math.max(0, (row?.runs_conceded || 0) + dRuns);
      const wk = Math.max(0, (row?.wickets || 0) + dWkts);
      const ov = Math.max(0, (row?.overs || 0) + dOvers);
      await supabaseClient.from("bowling_stats").update({
        runs_conceded: rc, wickets: wk, overs: ov
      }).eq("match_id", matchId).eq("bowler_name", p);
    }

    // ------- SCORES SAVE -------
    async function saveScore() {
      await supabaseClient.from("scores").upsert({
        match_id: matchId,
        runs, wickets, overs: oversDecimal(),
        striker, non_striker, bowler,
        commentary
      }, { onConflict: "match_id" });
    }

    // ------- LOAD TEAMS/PLAYERS -------
    async function loadTeams() {
      if (!matchId) return;

      // Load existing score row (resume state if present)
      const { data: s } = await supabaseClient.from("scores").select("*").eq("match_id", matchId).maybeSingle();
      if (s) {
        runs = s.runs || 0;
        wickets = s.wickets || 0;
        if (typeof s.overs === "number") {
          overs = Math.trunc(s.overs);
          balls = Math.round((s.overs - overs) * 10); // y digit is balls
        }
        striker = s.striker || "None";
        non_striker = s.non_striker || "None";
        bowler = s.bowler || "None";
        commentary = s.commentary || "";
      }

      const { data: matchData, error: mErr } = await supabaseClient
        .from("matches")
        .select("team1_id, team2_id, toss_winner, toss_decision")
        .eq("id", matchId).single();
      if (mErr || !matchData) { console.error("Error loading match:", mErr); return; }

      const { data: team1 } = await supabaseClient.from("teams").select("id, name, captain").eq("id", matchData.team1_id).single();
      const { data: team2 } = await supabaseClient.from("teams").select("id, name, captain").eq("id", matchData.team2_id).single();

      const t1Players = (await supabaseClient.from("players").select("name").eq("team_id", team1.id)).data?.map(p=>p.name) || [];
      const t2Players = (await supabaseClient.from("players").select("name").eq("team_id", team2.id)).data?.map(p=>p.name) || [];

      // Decide batting order from toss
      const tw = matchData.toss_winner, td = matchData.toss_decision;
      if (tw==="team1" && td==="bat" || tw==="team2" && td==="bowl") {
        battingTeam = team1.name; bowlingTeam = team2.name; battingPlayers = t1Players; bowlingPlayers = t2Players;
      } else {
        battingTeam = team2.name; bowlingTeam = team1.name; battingPlayers = t2Players; bowlingPlayers = t1Players;
      }
      team1Captain = team1.captain || ""; team2Captain = team2.captain || "";

      // Fill selects with (C) for captains
      const strikerSel = document.getElementById("strikerSelect");
      const nonSel = document.getElementById("nonStrikerSelect");
      const bowlSel = document.getElementById("bowlerSelect");
      const bowlingCaptain = (bowlingTeam === team1.name) ? team1Captain : team2Captain;
      const battingCaptain = (battingTeam === team1.name) ? team1Captain : team2Captain;

      strikerSel.innerHTML = "<option value=''>-- Select --</option>";
      nonSel.innerHTML = "<option value=''>-- Select --</option>";
      bowlSel.innerHTML = "<option value=''>-- Select --</option>";

      battingPlayers.forEach(p=>{
        const label = (p===battingCaptain && p) ? `${p} (C)` : p;
        strikerSel.innerHTML += `<option value="${p}">${label}</option>`;
        nonSel.innerHTML += `<option value="${p}">${label}</option>`;
      });
      bowlingPlayers.forEach(p=>{
        const label = (p===bowlingCaptain && p) ? `${p} (C)` : p;
        bowlSel.innerHTML += `<option value="${p}">${label}</option>`;
      });

      document.getElementById("battingTeam").textContent = `Batting Team: ${battingTeam}`;
      document.getElementById("bowlingTeam").textContent = `Bowling Team: ${bowlingTeam}`;

      // Reflect existing names if any
      if (striker !== "None") strikerSel.value = striker;
      if (non_striker !== "None") nonSel.value = non_striker;
      if (bowler !== "None") bowlSel.value = bowler;

      updateDisplay();
      // Ensure row exists in scores
      await saveScore();
    }

    // ------- CONFIRM / NEW SELECTIONS -------
    async function confirmPlayers() {
      striker = document.getElementById("strikerSelect").value;
      non_striker = document.getElementById("nonStrikerSelect").value;
      bowler = document.getElementById("bowlerSelect").value;

      if (!striker || !non_striker || !bowler) {
        alert("Please select striker, non-striker, and bowler before starting!");
        return;
      }
      if (striker === non_striker) {
        alert("Striker and Non-Striker must be different.");
        return;
      }

      await ensureBattingRow(striker);
      await ensureBattingRow(non_striker);
      await ensureBowlingRow(bowler);

      // Lock selections; enable scoring
      document.querySelectorAll("#selectorsBox select").forEach(el=>el.disabled = true);
      document.getElementById("btnConfirmInitial").disabled = true;
      enableScoring(true);

      await saveScore();
      updateDisplay();
    }

    function requireNewBatsman() {
      waitingNewBatsman = true;
      document.getElementById("strikerSelect").disabled = false;
      document.getElementById("btnConfirmNewBat").style.display = "inline-block";
      enableScoring(false);
    }
    async function setNewBatsman() {
      const newBat = document.getElementById("strikerSelect").value;
      if (!newBat || newBat === non_striker) {
        alert("Select a valid new batsman.");
        return;
      }
      striker = newBat;
      await ensureBattingRow(striker);

      waitingNewBatsman = false;
      document.getElementById("strikerSelect").disabled = true;
      document.getElementById("btnConfirmNewBat").style.display = "none";
      enableScoring(true);

      commentary = `${striker} comes to the crease.`;
      await saveScore();
      updateDisplay();
    }

    function openBowlerModal() {
      const modal = document.getElementById("bowlerModal");
      const sel = document.getElementById("newBowlerSelect");
      sel.innerHTML = "<option value=''>-- Select Bowler --</option>";
      bowlingPlayers.forEach(p => sel.innerHTML += `<option value="${p}">${p}</option>`);
      modal.style.display = "flex";
    }
    function closeBowlerModal() {
      document.getElementById("bowlerModal").style.display = "none";
    }
    async function confirmBowlerModal() {
      const val = document.getElementById("newBowlerSelect").value;
      if (!val) { alert("Pick a bowler"); return; }
      bowler = val;
      await ensureBowlingRow(bowler);
      commentary = `New over by ${bowler}.`;
      await saveScore();
      updateDisplay();
      closeBowlerModal();
      waitingNewBowler = false;
      enableScoring(true);
    }
    function requireNewBowler() {
      waitingNewBowler = true;
      enableScoring(false);
      openBowlerModal();
    }
    async function setNewBowler() {
      // Fallback button (kept for parity), uses current #bowlerSelect
      const b = document.getElementById("bowlerSelect").value;
      if (!b) { alert("Select a bowler."); return; }
      bowler = b;
      await ensureBowlingRow(bowler);
      waitingNewBowler = false;
      document.getElementById("btnConfirmNewBowler").style.display = "none";
      enableScoring(true);
      commentary = `New over by ${bowler}.`;
      await saveScore();
      updateDisplay();
    }

    // ------- BALL/OVER FLOW -------
    function advanceBallAndMaybeOver() {
      balls++;
      if (balls >= 6) {
        balls = 0; overs++;
        [striker, non_striker] = [non_striker, striker]; // strike rotates at over end
        return true;
      }
      return false;
    }

    // ------- SCORING -------
    async function addRun(r) {
      if (waitingNewBatsman || waitingNewBowler) return;

      // Snapshot before change for undo
      const snap = { type: "run", r, prev: { runs, wickets, overs, balls, striker, non_striker, bowler }};

      runs += r;
      const overEnded = advanceBallAndMaybeOver();

      // odd runs rotate strike unless over ended already did
      if (!overEnded && (r % 2 === 1)) [striker, non_striker] = [non_striker, striker];

      // stats
      await ensureBattingRow(striker);
      await adjBatting(striker, r, 1, r===4?1:0, r===6?1:0);
      await ensureBowlingRow(bowler);
      await adjBowling(bowler, r, 0, overEnded?1:0);

      commentary = `${striker} scores ${r} run${r>1?"s":""}.`;
      await saveScore();
      updateDisplay();

      // record undo info (including if over ended to roll back bowler overs)
      snap.overEnded = overEnded;
      pushHistory(snap);

      if (overEnded) requireNewBowler();
    }

    async function addExtra() {
      if (waitingNewBatsman || waitingNewBowler) return;
      const type = document.getElementById("extrasType").value;
      const x = parseInt(document.getElementById("extrasRuns").value || "1", 10);
      if (x <= 0) return;

      const snap = { type: "extra", subtype: type, x, prev: { runs, wickets, overs, balls, striker, non_striker, bowler } };

      if (type === "wide" || type === "no_ball") {
        runs += x; // not a ball
        await ensureBowlingRow(bowler);
        await adjBowling(bowler, x, 0, 0);
        commentary = `${type.replace("_"," ")} +${x}`;
        await saveScore(); updateDisplay();
        pushHistory(snap);
      } else if (type === "leg_bye") {
        runs += x;
        const overEnded = advanceBallAndMaybeOver();
        if (!overEnded && (x % 2 === 1)) [striker, non_striker] = [non_striker, striker];
        await ensureBowlingRow(bowler);
        await adjBowling(bowler, x, 0, overEnded?1:0);
        commentary = `Leg bye +${x}`;
        await saveScore(); updateDisplay();
        snap.overEnded = overEnded;
        pushHistory(snap);
        if (overEnded) requireNewBowler();
      }
    }

    async function addWicket() {
      if (waitingNewBatsman || waitingNewBowler) { alert("Confirm selection first!"); return; }
      const snap = { type: "wicket", prev: { runs, wickets, overs, balls, striker, non_striker, bowler } };

      wickets++;
      const overEnded = advanceBallAndMaybeOver();

      await ensureBowlingRow(bowler);
      await adjBowling(bowler, 0, 1, overEnded?1:0);
      await setBatsmanOut(striker, true);

      // Insert dismissal row
      const dismissalType = document.getElementById("dismissalType").value;
      const fielderName = document.getElementById("fielderName")?.value || null;
      const { data: dism } = await supabaseClient.from("dismissals").insert({
        match_id: matchId, batsman: striker, bowler: bowler,
        fielder: fielderName, dismissal_type: dismissalType
      }).select().single();
      snap.dismissal_id = dism?.id || null;

      commentary = `WICKET! ${striker} ${dismissalType}${fielderName ? " by " + fielderName : ""}`;
      await saveScore(); updateDisplay();

      snap.overEnded = overEnded;
      pushHistory(snap);

      if (overEnded) requireNewBowler();
      requireNewBatsman();
    }

    function swapStrike(manual=false) {
      if (waitingNewBatsman || waitingNewBowler) return;
      const snap = { type: "swap", prev: { runs, wickets, overs, balls, striker, non_striker, bowler } };
      [striker, non_striker] = [non_striker, striker];
      commentary = manual ? "Strike rotated manually." : "Strike rotated.";
      saveScore(); updateDisplay();
      pushHistory(snap);
    }

    // ------- END INNINGS (UPDATED) -------
    async function endInnings() {
      // Save state, then swap teams; reset score for new innings; refresh selectors; keep history for undo.
      const snap = { 
        type: "end_innings", 
        prev: { 
          runs, wickets, overs, balls, striker, non_striker, bowler, battingTeam, bowlingTeam, 
          battingPlayers:[...battingPlayers], bowlingPlayers:[...bowlingPlayers] 
        } 
      };

      commentary = "Innings ended.";
      await saveScore(); 
      updateDisplay();

      // Switch innings (swap teams and players)
      [battingTeam, bowlingTeam] = [bowlingTeam, battingTeam];
      [battingPlayers, bowlingPlayers] = [bowlingPlayers, battingPlayers];

      // Reset match stats for new innings (NRR will show 0.00 due to 0 overs)
      runs = 0; wickets = 0; overs = 0; balls = 0;
      striker = "None"; non_striker = "None"; bowler = "None";

      // Repopulate selectors with new batting/bowling teams
      const strikerSel = document.getElementById("strikerSelect");
      const nonSel = document.getElementById("nonStrikerSelect");
      const bowlSel = document.getElementById("bowlerSelect");

      strikerSel.innerHTML = "<option value=''>-- Select --</option>";
      nonSel.innerHTML = "<option value=''>-- Select --</option>";
      bowlSel.innerHTML = "<option value=''>-- Select --</option>";

      battingPlayers.forEach(p=>{
        strikerSel.innerHTML += `<option value="${p}">${p}</option>`;
        nonSel.innerHTML += `<option value="${p}">${p}</option>`;
      });
      bowlingPlayers.forEach(p=>{
        bowlSel.innerHTML += `<option value="${p}">${p}</option>`;
      });

      document.getElementById("battingTeam").textContent = `Batting Team: ${battingTeam}`;
      document.getElementById("bowlingTeam").textContent = `Bowling Team: ${bowlingTeam}`;

      // Unlock selects to choose fresh for 2nd innings; scoring remains disabled until confirmed
      document.getElementById("strikerSelect").disabled = false;
      document.getElementById("nonStrikerSelect").disabled = false;
      document.getElementById("bowlerSelect").disabled = false;
      document.getElementById("btnConfirmInitial").disabled = false;
      enableScoring(false);

      await saveScore(); 
      updateDisplay();
      pushHistory(snap);
    }

    // ------- UNDO -------
    async function undo() {
      const h = history.pop();
      if (!h) return;

      // Revert scores state
      runs = h.prev.runs; wickets = h.prev.wickets; overs = h.prev.overs; balls = h.prev.balls;
      striker = h.prev.striker; non_striker = h.prev.non_striker; bowler = h.prev.bowler;

      // Reverse DB side-effects for each op type
      if (h.type === "run") {
        await adjBatting(h.prev.striker, -h.r, -1, h.r===4?-1:0, h.r===6?-1:0);
        await adjBowling(h.prev.bowler, -h.r, 0, h.overEnded?-1:0);
      } else if (h.type === "extra") {
        if (h.subtype === "wide" || h.subtype === "no_ball") {
          await adjBowling(h.prev.bowler, -h.x, 0, 0);
        } else if (h.subtype === "leg_bye") {
          await adjBowling(h.prev.bowler, -h.x, 0, h.overEnded?-1:0);
        }
      } else if (h.type === "wicket") {
        await adjBowling(h.prev.bowler, 0, -1, h.overEnded?-1:0);
        await setBatsmanOut(h.prev.striker, false);
        if (h.dismissal_id) {
          await supabaseClient.from("dismissals").delete().eq("id", h.dismissal_id);
        } else {
          // fallback: delete most recent dismissal for that batsman in this match
          await supabaseClient.rpc("delete_last_dismissal_for_batsman", { match_in: matchId, batsman_in: h.prev.striker }).catch(()=>{});
        }
        // Cancel any pending new-batsman flow
        waitingNewBatsman = false;
        document.getElementById("btnConfirmNewBat").style.display = "none";
        document.getElementById("strikerSelect").disabled = true;
      } else if (h.type === "swap") {
        // state already restored above
      } else if (h.type === "end_innings") {
        battingTeam = h.prev.battingTeam; bowlingTeam = h.prev.bowlingTeam;
        battingPlayers = h.prev.battingPlayers; bowlingPlayers = h.prev.bowlingPlayers;
      }

      await saveScore(); updateDisplay();
      if (history.length === 0) document.getElementById("btnUndo").disabled = true;

      // Close any modals and re-enable scoring
      closeBowlerModal();
      waitingNewBowler = false; waitingNewBatsman = false;
      enableScoring(true);
    }

    // ------- START -------
    loadTeams();
    // Initially disable scoring until players set
    enableScoring(false);
  </script>
</body>
</html>
